; define parameter sets to avoid duplication in modules
parameter_set
	io
		sequence_start = 1
		camera_start = 1

	save
		dir = /media/data/projekte/disposer/data_target
		tar = true

; 	calc
; 		use_dark_image = true
; 		use_bright_image = true
; 		use_second_direction = true
; 		gray_count = 7
; 		cosine_count = 8
; 		min_intensity = 0
; 		max_intensity = 255
; 		min_modulation = 4
; 		min_intensity_range = 4

; List of modules
module
	start1 = async_program
		command = test.sh
		parameters = Das "ist ein" "test" "so soll\" es\" sein   !\\" d 

	start2 = async_program
		command = test.sh
		parameters = Das "ist ein" te"st "so soll\" es\" sein   !\\" d 

	end1 = async_get

	end2 = async_get_string

	output = add_to_log

	load = big_loader
		parameter_set = io
		dir = /media/data/projekte/disposer_old/data_source
		big_pattern = ${id}_i_${cam}_${pos}.big
		tar = false
		sequence_count = 32
		camera_count = 2
		fixed_id = 0
		type_uint8 = true

	save_uint8_t = big_saver_uint8_t
		parameter_set = io
		parameter_set = save
		sequence_count = 32

	sub = subbitmap_uint8_t
		x = 0
		y = 0
		width = 2048
		height = 1280

	raster = raster_uint8_t
		raster = 1

; 	save_float = sequence_saver_float
; 		parameter_set = save
; 		parameter_set = calc
; 		name = hrth
; 
; 	calc_raw = phase_calculator
; 		parameter_set = calc
; 
; 	calc_fine = phase_calculator
; 		parameter_set = calc
; 		calc_fine = true
; 		trans_scale_xi = -10.54
; 		trans_scale_eta = -10.54
; 		trans_scale_pps = 0.02
; 		p_lambda = 16

; List of process chains
chain
	toTarSequence
		load
			->
				sequence = load
		save_uint8_t
			<-
				sequence = load

	toTarVector
		load
			->
				vector = load
		save_uint8_t
			<-
				vector = load

	toTarImage
		load
			->
				image = load
		save_uint8_t
			<-
				image = load

; 	toTar
; 		load
; 			->
; 				sequence = load
; 		raster
; 			<-
; 				sequence = load
; 			->
; 				sequence = out
; 		save_uint8_t
; 			<-
; 				sequence = out

; 	serial
; 		start1
; 			->
; 				future = async1
; 		end1
; 			<-
; 				future = async1
; 		start2
; 			->
; 				future_output = async2
; 		end2
; 			<-
; 				future = async2
; 			->
; 				result = message
; 		output
; 			<-
; 				string = message
; 
; 	parallel
; 		start1
; 			->
; 				future = async1
; 		start2
; 			->
; 				future_output = async2
; 		end1
; 			<-
; 				future = async1
; 		end2
; 			<-
; 				future = async2
; 			->
; 				result = message
; 		output
; 			<-
; 				string = message

; 	except
; 		load
; 			->
; 				sequence = load
; 		save_float
; 			<-
; 				; will throw, type mismatch (float <- uint8)
; 				sequence = load
; 
; 	raw phase
; 		load
; 			->
; 				sequence = load
; 		calc_raw
; 			<-
; 				sequence = load
; 			->
; 				xi_phase = raw
; 				xi_modulation = mod
; 		save_float
; 			<-
; 				sequence = raw
; 		save_uint8_t
; 			<-
; 				sequence = mod
; 
; 	fine phase
; 		load
; 			->
; 				sequence = load
; 		calc_fine
; 			<-
; 				sequence = load
; 			->
; 				eta_phase = fine
; 				eta_modulation = mod
; 		save_float
; 			<-
; 				sequence = fine
; 		save_uint8_t
; 			<-
; 				sequence = mod
